package testutils

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

const EADIDForDeleteTest = "sample_delete_1"
const FakeSolrHostAndPort = "fake-solr-host.library.nyu.edu:8080"
const TestEAD = "edip/mos_2024"

var ExpectedDeleteRequest = fmt.Sprintf(`<?xml version="1.0" encoding="UTF-8"?>
<delete>
  <query>ead_ssi:"%s"</query>
</delete>
`, EADIDForDeleteTest)

var hostHeaderRegExp = regexp.MustCompile("Host: 127.0.0.1:[0-9]+")
var addIdRegExp = regexp.MustCompile(`<field name="id">([a-z0-9_-]+)</field>`)
var deleteIdRegExp = regexp.MustCompile(`<query>ead_ssi:"([a-z0-9_-]+)"</query>`)

var tmpFilesDirPath = filepath.Join("testdata", "tmp", "actual")

func Clean() error {
	err := os.RemoveAll(tmpFilesDirPath)
	if err != nil {
		return err
	}

	err = os.MkdirAll(tmpFilesDirPath, 0700)
	if err != nil {
		return err
	}

	_, err = os.Create(filepath.Join(tmpFilesDirPath, ".gitkeep"))
	if err != nil {
		return err
	}

	return nil
}

func GetActualFileContents(testEAD string, fileID string) (string, error) {
	actualFile := tmpFile(testEAD, fileID)

	bytes, err := os.ReadFile(actualFile)
	if err != nil {
		return "", err
	}

	return string(bytes), nil
}

func GetExpectedPOSTRequestString(body string) string {
	return fmt.Sprintf("%s\n\n%s", getPOSTRequestHTTPHeadersString(body), body)
}

func GetID(dumpedRequest []byte) (string, error) {
	// First assume it's an Add request.
	addIDMatches := addIdRegExp.FindStringSubmatch(string(dumpedRequest))
	if len(addIDMatches) > 1 {
		return addIDMatches[1], nil
	}

	// Maybe it's a Delete request.
	deleteIDMatches := deleteIdRegExp.FindStringSubmatch(string(dumpedRequest))
	if len(deleteIDMatches) > 1 {
		return deleteIDMatches[1], nil
	}

	// It's either a Commit request, or a malformed request.
	return "", nil
}

// To match actual test request to golden values generated by `GetExpectedPOSTRequestString()`,
// we need to:
// 1) Replace the Host header with the dynamically generated Solr fake
// address with the expected fake address
// 2) Remove the carriage returns that Go HTTP client uses in the line breaks.
// (The HTTP spec statest that applications must accept CR, LF, and CRLF:
// https://www.rfc-editor.org/rfc/rfc2616#section-2.2)
func MassagedGoHTTPClientRequest(request string) string {
	massagedHostHeaderRequest := hostHeaderRegExp.ReplaceAllString(request,
		"Host: "+FakeSolrHostAndPort)

	return strings.ReplaceAll(massagedHostHeaderRequest, "\r", "")
}

func getPOSTRequestHTTPHeadersString(body string) string {
	// `Content-Length` should be size in bytes, not characters, so using
	// `len()` is correct, even if multi-rune characters are used in `body`.
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length
	var charLength = len(body)

	var postRequestHTTPHeadersString = fmt.Sprintf(
		`POST /solr/findingaids/update?wt=json&indent=true HTTP/1.1
Host: %s
Accept-Encoding: gzip
Content-Length: %s
Content-Type: text/xml
User-Agent: Go-http-client/1.1`, FakeSolrHostAndPort, strconv.Itoa(charLength))

	return postRequestHTTPHeadersString
}

func tmpFile(testEAD string, fileID string) string {
	return filepath.Join(tmpFilesDirPath, testEAD, fileID+".xml")
}

func writeActualSolrRequestToTmp(testEAD string, fileID string, actual string) error {
	tmpFile := tmpFile(testEAD, fileID)
	err := os.MkdirAll(filepath.Dir(tmpFile), 0755)
	if err != nil {
		return err
	}

	return os.WriteFile(tmpFile, []byte(actual), 0644)
}
